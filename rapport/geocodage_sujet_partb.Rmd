---
title: "Géocodage Sujet Gouramic partB"
author: "Olivier Leroy"
date: "24 mars 2020"
lang: fr-FR
output: 
    bookdown::html_document2:
        theme: readable
        toc: true
        toc_float: true
        number_sections: true
        toc_depth: 3
        fig_caption: true
        keep_md: true
        code_folding: hide
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
pkgs <-  c("dplyr","stringr", "lubridate", "ggplot2", "sf")
inst <- lapply(pkgs, library, character.only = TRUE)
```

# Traitements de géocodage

Il y a eu deux traitements un effectué par le CLB via ESRI [ref] et un effectué par EVS via l'API d'Etalab [ref]. 


```{r chargementgeocodage, include=FALSE}
allsujet_SansNA.dat <- readRDS("../data/allsujet_cleanNA.rds")
geocodage_evs.shp <- sf::st_read("../data/geocodev2.geojson", stringsAsFactors = FALSE)
geocodage_clb.shp <- sf::st_read("../data/Geocoding_Result.shp", stringsAsFactors = FALSE)
```


## Dictionnaire du geojson (geocode.geojson) produit par BanR : 

L'individu statistique ou la ligne correspond au couple sujet et adresse 

* **Id_cart**  =  ID_carto (Sujet + adresse format : DD_DDDD_D )   

* **Date_birth** = date de naissance (date)

* **Date_start** = date de début de l'adresse (date_time)

* **Date_end** = date de fin de l'adresse (date_time)

* **Commune** = Nom de la commune 

* **Info_sup** = concaténation deLieu_dit, Compl_add_p, pt_remarq_p 

* **Adresse** = Rue + nom de rue 

* **Code_postal** = Le code postal 

* **result_label,  result_score,  result_type, result_id, result_housenumber, result_name,  result_street,   result_postcode,  result_city, result_context ,  result_citycode,  result_oldcitycode, result_oldcity,  result_district** = colonnes produites par l'[API](https://cran.r-project.org/web/packages/banR/vignettes/geocode.html). Je les ai gardé pour la verif, on les virera probablement une fois les données jugées "propres".  Parmi ces dernières deux sont un peu plus intéressante pour nous

* **result_score** = un indice de 0-1 de confiance du géocodage (0 pas confiant, 1 très confiant : pas regardé comment il était calculé)

* **result_type** = la précision du géocodage 
    - housnumber = numéro de rue
    - street = à la rue
    - locality = lieu dit ou localité
    - municipality = commune..
    - NA = pas pu localiser quoi que ce soit

* **"Nun_adresse"** : ancien champ adresse

* **"Naissance"** : 0/1 Première adresse du sujet (considéré par définition comme naissance, est ce correcte ?)

* **interval_adresse** : Intervalle entre date_start et date_end. utile pour savoir si un stade de vie d'interet est dans tel ou tel interval cf  [lubridate](https://lubridate.tidyverse.org/articles/lubridate.html#time-intervals))

* **Enfance** = 0/1 l'adresse est elle dans interval_adresse pour 7-10 ans 

* **Adolescence**  = 0/1l'adresse est elle dans interval_adresse pour 11-15 ans

* **sujet** = l'id du sujet

* **Importance_adresse** = une somme de Naissance, Enfance et Adolesence pour identifier plus vite les adresses importantes nous manquants

* **source_loc** = source du geocodage pour le moment ne prend que "geocodage" et "main" pour celles faites à la main

* **geometry** = le champ geometry (la doc indique du wgs84 donc 4326 pour le scr)

Le code est [ici](https://github.com/defuneste/gouramic-db-analyses/blob/master/Pr%C3%A9traitement_ETL/clean_order_all_sujet.R)


## dictionnaire de donnée de Geocoding_Result.shp


* **Loc_name** correspond à la précision de la géolocalisation 
    - 1_PointAdresse
    - 2_AdresseInter
    - 3_Voie
    - 4_LieuDitHabit
    - 5_ChefLieu
    - 6_CodePostal
    - 7_Ville
    - NA
    
* **DisplayX et DisplayY** long/lat quand la Loc_name est différent de 1_PointAdresse

* **ID_SECONDA** Correspond à l'ID du sujet

* **ID_visite**
    

# Geocodage
